import { Body, Controller, Get, HttpCode, HttpStatus, Param, Post, Query, UseGuards } from '@nestjs/common';
import { AuthGuard }                                                                  from '@nestjs/passport';
import { ApiOperation, ApiParam, ApiResponse, ApiTags }                               from '@nestjs/swagger';
import { InjectRepository }                                                           from '@nestjs/typeorm';
import { Repository }                                                                 from 'typeorm';
import { IncidentEntity, IncidentSeverity, IncidentStatus }                           from '../domain/entities/incident.entity';
import { CreateIncidentDto }                                                          from '../domain/dto/create-incident.dto';

@ApiTags('Checklists - Incidents')
@UseGuards(AuthGuard('jwt'))
@Controller({
  path: 'incidents'
})
export class IncidentController {
  constructor(
    @InjectRepository(IncidentEntity)
    private readonly incidentRepository: Repository<IncidentEntity>,
  ) {}

  @ApiOperation({
    summary: 'Create a new incident',
    description: 'Create a new incident manually. Note: Most incidents are automatically created when checklist executions have low performance scores.'
  })
  @ApiResponse({
    status: 201,
    description: 'Incident created successfully',
    type: IncidentEntity
  })
  @ApiResponse({
    status: 400,
    description: 'Bad request - validation errors'
  })
  @Post()
  @HttpCode(HttpStatus.CREATED)
  async createIncident(@Body() dto: CreateIncidentDto): Promise<IncidentEntity> {
    const incident = this.incidentRepository.create({
      executionId: dto.executionId,
      title: dto.title,
      description: dto.description,
      severity: dto.severity,
      status: dto.status || IncidentStatus.OPEN,
      performanceScore: dto.performanceScore,
      thresholdScore: dto.thresholdScore,
      vehicleId: dto.vehicleId,
      reportedByUserId: dto.reportedByUserId,
      assignedToUserId: dto.assignedToUserId,
      autoGenerated: dto.autoGenerated || false,
      failedCategories: dto.failedCategories || [],
      resolutionNotes: dto.resolutionNotes,
      reportedAt: new Date(),
    });

    const savedIncident = await this.incidentRepository.save(incident);
    return this.findById(savedIncident.id);
  }

  @ApiOperation({
    summary: 'Get all incidents',
    description: 'Retrieve all incidents with filtering options'
  })
  @ApiResponse({
    status: 200,
    description: 'Returns list of incidents',
    schema: {
      type: 'object',
      properties: {
        total: {type: 'number', example: 25},
        items: {
          type: 'array',
          items: {$ref: '#/components/schemas/IncidentEntity'}
        }
      }
    }
  })
  @Get()
  @HttpCode(HttpStatus.OK)
  async findAllIncidents(@Query() query: any): Promise<{ total: number; items: IncidentEntity[] }> {
    const queryBuilder = this.incidentRepository.createQueryBuilder('incident')
      .leftJoinAndSelect('incident.execution', 'execution')
      .leftJoinAndSelect('incident.vehicle', 'vehicle')
      .leftJoinAndSelect('incident.reportedByUser', 'reportedByUser')
      .leftJoinAndSelect('incident.assignedToUser', 'assignedToUser');

    // Filter by severity
    if (query.severity) {
      queryBuilder.andWhere('incident.severity = :severity', {severity: query.severity});
    }

    // Filter by status
    if (query.status) {
      queryBuilder.andWhere('incident.status = :status', {status: query.status});
    }

    // Filter by vehicle ID
    if (query.vehicleId) {
      queryBuilder.andWhere('incident.vehicleId = :vehicleId', {vehicleId: query.vehicleId});
    }

    // Filter by execution ID
    if (query.executionId) {
      queryBuilder.andWhere('incident.executionId = :executionId', {executionId: query.executionId});
    }

    // Filter by auto-generated
    if (query.autoGenerated !== undefined) {
      const isAutoGenerated = query.autoGenerated === 'true';
      queryBuilder.andWhere('incident.autoGenerated = :autoGenerated', {autoGenerated: isAutoGenerated});
    }

    // Filter by reported user
    if (query.reportedByUserId) {
      queryBuilder.andWhere('incident.reportedByUserId = :reportedByUserId', {reportedByUserId: query.reportedByUserId});
    }

    // Filter by assigned user
    if (query.assignedToUserId) {
      queryBuilder.andWhere('incident.assignedToUserId = :assignedToUserId', {assignedToUserId: query.assignedToUserId});
    }

    // Date range filter
    if (query.startDate && query.endDate) {
      queryBuilder.andWhere('incident.reportedAt BETWEEN :startDate AND :endDate', {
        startDate: query.startDate,
        endDate: query.endDate
      });
    }

    // Pagination
    const page = parseInt(query.page) || 1;
    const limit = parseInt(query.limit) || 10;
    const skip = (page - 1) * limit;

    queryBuilder
      .orderBy('incident.reportedAt', 'DESC')
      .skip(skip)
      .take(limit);

    const [ items, total ] = await queryBuilder.getManyAndCount();
    return {total, items};
  }

  @ApiOperation({
    summary: 'Get incident by ID',
    description: 'Retrieve a specific incident with all related data'
  })
  @ApiResponse({
    status: 200,
    description: 'Returns the incident data',
    type: IncidentEntity
  })
  @ApiResponse({
    status: 404,
    description: 'Incident not found'
  })
  @ApiParam({name: 'id', description: 'Incident ID'})
  @Get(':id')
  @HttpCode(HttpStatus.OK)
  async findById(@Param('id') id: string): Promise<IncidentEntity> {
    const incident = await this.incidentRepository.findOne({
      where: {id},
      relations: [
        'execution',
        'execution.template',
        'execution.group',
        'execution.executorUser',
        'execution.targetVehicle',
        'vehicle',
        'reportedByUser',
        'assignedToUser'
      ]
    });

    if (!incident) {
      throw new Error(`Incident with ID ${ id } not found`);
    }

    return incident;
  }

  @ApiOperation({
    summary: 'Get incidents by vehicle',
    description: 'Get all incidents for a specific vehicle'
  })
  @ApiResponse({
    status: 200,
    description: 'Returns list of incidents for the vehicle',
    type: [ IncidentEntity ]
  })
  @ApiParam({name: 'vehicleId', description: 'Vehicle ID'})
  @Get('vehicle/:vehicleId')
  @HttpCode(HttpStatus.OK)
  async findByVehicle(@Param('vehicleId') vehicleId: string): Promise<IncidentEntity[]> {
    const query = {vehicleId};
    const {items} = await this.findAllIncidents(query);
    return items;
  }

  @ApiOperation({
    summary: 'Get incidents by execution',
    description: 'Get all incidents for a specific checklist execution'
  })
  @ApiResponse({
    status: 200,
    description: 'Returns list of incidents for the execution',
    type: [ IncidentEntity ]
  })
  @ApiParam({name: 'executionId', description: 'Execution ID'})
  @Get('execution/:executionId')
  @HttpCode(HttpStatus.OK)
  async findByExecution(@Param('executionId') executionId: string): Promise<IncidentEntity[]> {
    const query = {executionId};
    const {items} = await this.findAllIncidents(query);
    return items;
  }

  @ApiOperation({
    summary: 'Get auto-generated incidents',
    description: 'Get all incidents that were automatically generated by the system'
  })
  @ApiResponse({
    status: 200,
    description: 'Returns list of auto-generated incidents',
    type: [ IncidentEntity ]
  })
  @Get('auto-generated/list')
  @HttpCode(HttpStatus.OK)
  async findAutoGenerated(): Promise<IncidentEntity[]> {
    const query = {autoGenerated: 'true'};
    const {items} = await this.findAllIncidents(query);
    return items;
  }

  @ApiOperation({
    summary: 'Get incidents by severity',
    description: 'Get all incidents with a specific severity level'
  })
  @ApiResponse({
    status: 200,
    description: 'Returns list of incidents with the specified severity',
    type: [ IncidentEntity ]
  })
  @ApiParam({name: 'severity', description: 'Incident severity', enum: IncidentSeverity})
  @Get('severity/:severity')
  @HttpCode(HttpStatus.OK)
  async findBySeverity(@Param('severity') severity: IncidentSeverity): Promise<IncidentEntity[]> {
    const query = {severity};
    const {items} = await this.findAllIncidents(query);
    return items;
  }

  @ApiOperation({
    summary: 'Get open incidents',
    description: 'Get all incidents with open status'
  })
  @ApiResponse({
    status: 200,
    description: 'Returns list of open incidents',
    type: [ IncidentEntity ]
  })
  @Get('status/open')
  @HttpCode(HttpStatus.OK)
  async findOpenIncidents(): Promise<IncidentEntity[]> {
    const query = {status: IncidentStatus.OPEN};
    const {items} = await this.findAllIncidents(query);
    return items;
  }
}
